{"ast":null,"code":"import Chess from \"chess.js\";\n/* \n    - Create copy of chess board\n    - get moves\n    - go through each move and get its evaluation\n    - run minmax evaulating each move to a height of 3\n*/\n\n/* based on stockfish midgame piece evaluations\nPawnValueMg = 128, \nKnightValueMg = 781,\nBishopValueMg = 825, \nRookValueMg = 1276, \nQueenValueMg = 2538,\n\n*/\n\nlet pieceValues = new Map();\npieceValues['p'] = 128;\npieceValues['n'] = 781;\npieceValues['b'] = 128;\npieceValues['r'] = 1276;\npieceValues['q'] = 2538;\npieceValues['k'] = 9999;\n\nconst miniMaxRecursive = (chessCopy, depth, allEval, isMax) => {\n  allEval[depth].push({\n    score: getBoardEvaluation(chessCopy.board()),\n    move: \"leaf\"\n  });\n\n  if (depth === 0) {\n    return [null, getBoardEvaluation(chessCopy.board())];\n  }\n\n  const moves = chessCopy.moves();\n  let bestMove = moves[moves.length - 1];\n\n  if (isMax) {\n    let maxEval = -Infinity;\n\n    for (let i = 0; i < moves.length; i++) {\n      chessCopy.move(moves[i]);\n      allEval[depth].push({\n        score: getBoardEvaluation(chessCopy.board()),\n        move: moves[i],\n        moves: `${i}/${moves.length}`\n      });\n      let currentEval = miniMaxRecursive(chessCopy, depth - 1, allEval, false)[1];\n      chessCopy.undo();\n      console.log(\"Current Eval: \" + currentEval + \"| Max Eval \" + maxEval);\n\n      if (currentEval > maxEval) {\n        maxEval = currentEval;\n        bestMove = moves[i];\n      }\n    }\n\n    return [bestMove, maxEval];\n  } else {\n    let minEval = Infinity;\n\n    for (let i = 0; i < moves.length; i++) {\n      chessCopy.move(moves[i]);\n      allEval[depth].push({\n        score: getBoardEvaluation(chessCopy.board()),\n        move: moves[i],\n        moves: `${i}/${moves.length - 1}`\n      });\n      let currentEval = miniMaxRecursive(chessCopy, depth - 1, allEval, true)[1];\n      chessCopy.undo();\n\n      if (currentEval < minEval) {\n        minEval = currentEval;\n        bestMove = moves[i];\n      }\n    }\n\n    return [bestMove, minEval];\n  }\n};\n\nconst fetchBestMove = async (chessCopy, depth, allEval, isMax) => {\n  const bestMove = await miniMaxRecursive(chessCopy, depth, allEval, isMax);\n  console.log(bestMove);\n  return bestMove[0];\n};\n\nconst MiniMax = (chess, updateComputerHistory, setFen) => {\n  const allEval = [[], [], []];\n  const chessCopy = new Chess(chess.fen()); // computer response random\n\n  fetchBestMove(chessCopy, 2, allEval, true).then(bestMove => {\n    // update position\n    chess.move(bestMove);\n    console.log(allEval); // add move to history\n\n    updateComputerHistory(bestMove); // update chessboard\n\n    setFen(chess.fen());\n  });\n};\n\n_c = MiniMax;\n\nconst getBoardEvaluation = board => {\n  let count = 0;\n\n  for (let i = 0; i < board.length; i++) {\n    for (let j = 0; j < board[i].length; j++) {\n      if (board[i][j] === null) continue;\n      let piece = board[i][j].type;\n      let color = board[i][j].color;\n\n      if (color === 'b') {\n        count += pieceValues[piece];\n      } else {\n        count -= pieceValues[piece];\n      }\n    }\n  }\n\n  return count;\n};\n\nexport default MiniMax;\n\nvar _c;\n\n$RefreshReg$(_c, \"MiniMax\");","map":{"version":3,"sources":["/Users/donavynhaley/Documents/GitHub/chess-ai/chess-ai/src/components/bots/MiniMax.js"],"names":["Chess","pieceValues","Map","miniMaxRecursive","chessCopy","depth","allEval","isMax","push","score","getBoardEvaluation","board","move","moves","bestMove","length","maxEval","Infinity","i","currentEval","undo","console","log","minEval","fetchBestMove","MiniMax","chess","updateComputerHistory","setFen","fen","then","count","j","piece","type","color"],"mappings":"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","sourcesContent":["import Chess from \"chess.js\";\n\n/* \n    - Create copy of chess board\n    - get moves\n    - go through each move and get its evaluation\n    - run minmax evaulating each move to a height of 3\n*/\n\n/* based on stockfish midgame piece evaluations\nPawnValueMg = 128, \nKnightValueMg = 781,\nBishopValueMg = 825, \nRookValueMg = 1276, \nQueenValueMg = 2538,\n\n*/\nlet pieceValues = new Map()\npieceValues['p'] = 128;\npieceValues['n'] = 781;\npieceValues['b'] = 128;\npieceValues['r'] = 1276;\npieceValues['q'] = 2538;\npieceValues['k'] = 9999;\n\nconst miniMaxRecursive = (chessCopy, depth, allEval, isMax) => {\n    allEval[depth].push({ score: getBoardEvaluation(chessCopy.board()), move: \"leaf\" })\n    if (depth === 0) {\n        return [null, getBoardEvaluation(chessCopy.board())];\n    }\n    const moves = chessCopy.moves();\n    let bestMove = moves[moves.length - 1];\n\n    if (isMax) {\n        let maxEval = -Infinity;\n        for (let i = 0; i < moves.length; i++) {\n            chessCopy.move(moves[i])\n            allEval[depth].push({ score: getBoardEvaluation(chessCopy.board()), move: moves[i], moves: `${i}/${moves.length}` })\n            let currentEval = miniMaxRecursive(chessCopy, depth - 1, allEval, false)[1];\n            chessCopy.undo();\n            console.log(\"Current Eval: \" + currentEval + \"| Max Eval \" + maxEval)\n            if (currentEval > maxEval) {\n                maxEval = currentEval;\n                bestMove = moves[i];\n            }\n        }\n        return [bestMove, maxEval];\n\n    }\n    else {\n        let minEval = Infinity;\n        for (let i = 0; i < moves.length; i++) {\n            chessCopy.move(moves[i])\n            allEval[depth].push({ score: getBoardEvaluation(chessCopy.board()), move: moves[i], moves: `${i}/${moves.length - 1}` })\n            let currentEval = miniMaxRecursive(chessCopy, depth - 1, allEval, true)[1];\n            chessCopy.undo()\n            if (currentEval < minEval) {\n                minEval = currentEval;\n                bestMove = moves[i];\n            }\n        }\n        return [bestMove, minEval]\n    }\n\n}\n\nconst fetchBestMove = async (chessCopy, depth, allEval, isMax) => {\n    const bestMove = await miniMaxRecursive(chessCopy, depth, allEval, isMax)\n    console.log(bestMove)\n    return bestMove[0]\n}\n\nconst MiniMax = (chess, updateComputerHistory, setFen) => {\n    const allEval = [[], [], []]\n    const chessCopy = new Chess(chess.fen());\n    // computer response random\n    fetchBestMove(chessCopy, 2, allEval, true).then((bestMove) => {\n        // update position\n        chess.move(bestMove)\n        console.log(allEval)\n        // add move to history\n        updateComputerHistory(bestMove);\n        // update chessboard\n        setFen(chess.fen());\n    })\n}\nconst getBoardEvaluation = (board) => {\n    let count = 0;\n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[i].length; j++) {\n            if (board[i][j] === null)\n                continue\n            let piece = board[i][j].type\n            let color = board[i][j].color\n            if (color === 'b') {\n                count += pieceValues[piece]\n            }\n            else {\n                count -= pieceValues[piece]\n            }\n        }\n    }\n    return count\n}\n\nexport default MiniMax\n"]},"metadata":{},"sourceType":"module"}