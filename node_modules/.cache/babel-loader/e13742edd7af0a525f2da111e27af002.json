{"ast":null,"code":"import Chess from \"chess.js\";\nimport getBoardEvaluation from './getBoardEvaluation';\n\nconst miniMaxRecursive = (chessCopy, depth, allEval, isMax) => {\n  if (depth === 0) {\n    return [null, getBoardEvaluation(chessCopy.fen())];\n  }\n\n  const moves = chessCopy.moves();\n  let bestMove = moves[Math.floor(Math.random() * moves.length)];\n\n  if (isMax) {\n    let maxEval = -Infinity;\n\n    for (let i = 0; i < moves.length; i++) {\n      // Update move\n      chessCopy.move(moves[i]); // Push board eval to list\n\n      allEval[depth - 1].push({\n        score: getBoardEvaluation(chessCopy.fen()),\n        move: moves[i],\n        currentMove: i,\n        totalMoves: moves.length - 1,\n        isMax: true\n      }); // Recursive call minimax with lower depth\n\n      let currentEval = miniMaxRecursive(chessCopy, depth - 1, allEval, false)[1]; // Undo move\n\n      chessCopy.undo(); // Sets best move according to currentEval max\n\n      if (currentEval > maxEval) {\n        maxEval = currentEval;\n        bestMove = moves[i];\n      }\n    }\n\n    return [bestMove, maxEval];\n  } else {\n    let minEval = Infinity;\n\n    for (let i = 0; i < moves.length; i++) {\n      // Update move\n      chessCopy.move(moves[i]); // Push board eval to list\n\n      allEval[depth - 1].push({\n        score: getBoardEvaluation(chessCopy.fen()),\n        move: moves[i],\n        currentMove: i,\n        totalMoves: moves.length - 1,\n        isMax: true\n      }); // Recursive call minimax with lower depth\n\n      let currentEval = miniMaxRecursive(chessCopy, depth - 1, allEval, true)[1]; // Undo move\n\n      chessCopy.undo(); // Sets best move according to currentEval min\n\n      if (currentEval < minEval) {\n        minEval = currentEval;\n        bestMove = moves[i];\n      }\n    }\n\n    return [bestMove, minEval];\n  }\n};\n\nconst fetchBestMove = async (chessCopy, depth, allEval, isMax) => {\n  const bestMove = await miniMaxRecursive(chessCopy, depth, allEval, isMax);\n  return bestMove[0];\n};\n\nconst toTreeData = (allEval, treeData, depth) => {\n  let i = depth - 1;\n\n  for (let j = 0; j < allEval[i].length; j++) {\n    treeData.children.push({\n      name: allEval[i][j].move,\n      attributes: {\n        score: allEval[i][j].score\n      },\n      children: []\n    });\n  }\n\n  i -= 1;\n  let index = 0;\n\n  for (let j = 0; j < allEval[i].length; j++) {\n    treeData.children[index].children.push({\n      name: allEval[i][j].move,\n      attributes: {\n        score: allEval[i][j].score,\n        currentMove: allEval[i][j].currentMove,\n        totalMoves: allEval[i][j].totalMoves\n      },\n      children: []\n    });\n\n    if (allEval[i][j].currentMove === allEval[i][j].totalMoves) {\n      index += 1;\n    }\n  }\n\n  index = 0;\n  let indexTwo = 0;\n  i -= 1;\n\n  for (let j = 0; j < allEval[i].length; j++) {\n    treeData.children[indexTwo].children[index].children.push({\n      name: allEval[i][j].move,\n      attributes: {\n        score: allEval[i][j].score,\n        currentMove: allEval[i][j].currentMove,\n        totalMoves: allEval[i][j].totalMoves\n      },\n      children: []\n    });\n\n    if (allEval[i][j].currentMove === allEval[i][j].totalMoves) {\n      index += 1;\n\n      if (index >= treeData.children[indexTwo].children.length) {\n        indexTwo += 1;\n        index = 0;\n      }\n    }\n  }\n\n  return treeData;\n};\n\nconst MiniMax = (chess, updateComputerHistory, setFen, setEvalCount, setTreeData) => {\n  const allEval = [[], [], []];\n  const treeData = {\n    name: \"Start\",\n    attributes: {\n      score: getBoardEvaluation(chess.fen())\n    },\n    children: []\n  };\n  const chessCopy = new Chess(chess.fen());\n  fetchBestMove(chessCopy, 3, allEval, true).then(bestMove => {\n    // update position\n    chess.move(bestMove);\n    console.log(allEval); // Update eval count\n\n    const totalEvaluations = allEval.map(evaluation => {\n      return evaluation.length;\n    });\n    setEvalCount(totalEvaluations.reduce((a, b) => a + b, 0)); // convert to tree data\n\n    setTreeData(toTreeData(allEval, treeData, 3)); // add move to history\n\n    updateComputerHistory(bestMove); // update chessboard\n\n    setFen(chess.fen());\n  });\n};\n\n_c = MiniMax;\nexport default MiniMax;\n\nvar _c;\n\n$RefreshReg$(_c, \"MiniMax\");","map":{"version":3,"sources":["/Users/donavynhaley/Documents/GitHub/chess-ai/chess-ai/src/components/bots/MiniMax.js"],"names":["Chess","getBoardEvaluation","miniMaxRecursive","chessCopy","depth","allEval","isMax","fen","moves","bestMove","Math","floor","random","length","maxEval","Infinity","i","move","push","score","currentMove","totalMoves","currentEval","undo","minEval","fetchBestMove","toTreeData","treeData","j","children","name","attributes","index","indexTwo","MiniMax","chess","updateComputerHistory","setFen","setEvalCount","setTreeData","then","console","log","totalEvaluations","map","evaluation","reduce","a","b"],"mappings":"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","sourcesContent":["import Chess from \"chess.js\";\nimport getBoardEvaluation from './getBoardEvaluation'\n\n\nconst miniMaxRecursive = (chessCopy, depth, allEval, isMax) => {\n    if (depth === 0) {\n        return [null, getBoardEvaluation(chessCopy.fen())];\n    }\n\n    const moves = chessCopy.moves();\n    let bestMove = moves[Math.floor(Math.random() * moves.length)];\n\n    if (isMax) {\n        let maxEval = -Infinity;\n        for (let i = 0; i < moves.length; i++) {\n            // Update move\n            chessCopy.move(moves[i])\n            // Push board eval to list\n            allEval[depth - 1].push({ score: getBoardEvaluation(chessCopy.fen()), move: moves[i], currentMove: i, totalMoves: moves.length - 1, isMax: true })\n            // Recursive call minimax with lower depth\n            let currentEval = miniMaxRecursive(chessCopy, depth - 1, allEval, false)[1];\n            // Undo move\n            chessCopy.undo();\n            // Sets best move according to currentEval max\n            if (currentEval > maxEval) {\n                maxEval = currentEval;\n                bestMove = moves[i];\n            }\n        }\n        return [bestMove, maxEval];\n    }\n    else {\n        let minEval = Infinity;\n        for (let i = 0; i < moves.length; i++) {\n            // Update move\n            chessCopy.move(moves[i])\n            // Push board eval to list\n            allEval[depth - 1].push({ score: getBoardEvaluation(chessCopy.fen()), move: moves[i], currentMove: i, totalMoves: moves.length - 1, isMax: true })\n            // Recursive call minimax with lower depth\n            let currentEval = miniMaxRecursive(chessCopy, depth - 1, allEval, true)[1];\n            // Undo move\n            chessCopy.undo()\n            // Sets best move according to currentEval min\n            if (currentEval < minEval) {\n                minEval = currentEval;\n                bestMove = moves[i];\n            }\n        }\n        return [bestMove, minEval]\n    }\n}\n\nconst fetchBestMove = async (chessCopy, depth, allEval, isMax) => {\n    const bestMove = await miniMaxRecursive(chessCopy, depth, allEval, isMax)\n    return bestMove[0]\n}\n\nconst toTreeData = (allEval, treeData, depth) => {\n    let i = depth - 1\n    for (let j = 0; j < allEval[i].length; j++) {\n        treeData.children.push({\n            name: allEval[i][j].move,\n            attributes: {\n                score: allEval[i][j].score,\n            },\n            children: []\n        })\n    }\n    i -= 1\n    let index = 0\n    for (let j = 0; j < allEval[i].length; j++) {\n        treeData.children[index].children.push({\n            name: allEval[i][j].move,\n            attributes: {\n                score: allEval[i][j].score,\n                currentMove: allEval[i][j].currentMove,\n                totalMoves: allEval[i][j].totalMoves,\n            },\n            children: []\n        })\n        if (allEval[i][j].currentMove === allEval[i][j].totalMoves) {\n            index += 1\n        }\n    }\n    index = 0\n    let indexTwo = 0\n    i -= 1\n    for (let j = 0; j < allEval[i].length; j++) {\n        treeData.children[indexTwo].children[index].children.push({\n            name: allEval[i][j].move,\n            attributes: {\n                score: allEval[i][j].score,\n                currentMove: allEval[i][j].currentMove,\n                totalMoves: allEval[i][j].totalMoves,\n            },\n            children: []\n        })\n        if (allEval[i][j].currentMove === allEval[i][j].totalMoves) {\n            index += 1\n            if (index >= treeData.children[indexTwo].children.length) {\n                indexTwo += 1\n                index = 0\n            }\n        }\n    }\n    return treeData\n}\nconst MiniMax = (chess, updateComputerHistory, setFen, setEvalCount, setTreeData) => {\n    const allEval = [[], [], []]\n    const treeData = {\n        name: \"Start\",\n        attributes: {\n            score: getBoardEvaluation(chess.fen()),\n        },\n        children: []\n    }\n    const chessCopy = new Chess(chess.fen());\n    fetchBestMove(chessCopy, 3, allEval, true).then((bestMove) => {\n\n        // update position\n        chess.move(bestMove);\n        console.log(allEval);\n\n        // Update eval count\n        const totalEvaluations = allEval.map((evaluation) => {\n            return evaluation.length\n        })\n        setEvalCount(totalEvaluations.reduce((a, b) => a + b, 0))\n\n        // convert to tree data\n        setTreeData(toTreeData(allEval, treeData, 3))\n        // add move to history\n        updateComputerHistory(bestMove);\n\n        // update chessboard\n        setFen(chess.fen());\n    })\n}\n\n\nexport default MiniMax\n"]},"metadata":{},"sourceType":"module"}