{"ast":null,"code":"import Chess from \"chess.js\";\n/* \n    - Create copy of chess board\n    - get moves\n    - go through each move and get its evaluation\n    - run minmax evaulating each move to a height of 3\n*/\n\n/* based on stockfish midgame piece evaluations\nPawnValueMg = 128, \nKnightValueMg = 781,\nBishopValueMg = 825, \nRookValueMg = 1276, \nQueenValueMg = 2538,\n\n*/\n\nlet pieceValues = new Map();\npieceValues['p'] = 128;\npieceValues['n'] = 781;\npieceValues['b'] = 128;\npieceValues['r'] = 1276;\npieceValues['q'] = 2538;\npieceValues['k'] = 9999;\n\nconst buildTree = (chessCopy, moves, depth, allEval, originalFen) => {\n  for (let d = 0; d < depth; d++) {\n    for (let i = 0; i < moves.length; i++) {\n      chessCopy.move(moves[i]);\n      allEval.push({\n        score: getBoardEvaluation(chessCopy.board()),\n        move: moves[i],\n        depth: d\n      });\n      chessCopy.load(originalFen);\n    }\n  }\n};\n\nconst MiniMax = (chess, updateComputerHistory, setRandomBotAvaliableMoves, setFen) => {\n  const originalFen = chess.fen();\n  const allEval = [];\n  const chessCopy = new Chess(chess.fen());\n  allEval.push({\n    score: getBoardEvaluation(chess.board),\n    move: 'origninal',\n    depth: 2\n  }); // computer response random\n\n  setTimeout(() => {\n    // Get list of valid moves and adds evaluation for each possible move to list\n    const moves = chessCopy.moves();\n    buildTree(chessCopy, moves, 3, allEval, originalFen);\n    console.log(allEval); // update state for data vizualization\n    // setRandomBotAvaliableMoves(moves);\n    // If valid move is avaliable selects random and updates chessboard\n\n    if (moves.length > 0) {\n      const computerMove = moves[Math.floor(Math.random() * moves.length)];\n      chess.move(computerMove); // add move to history\n\n      updateComputerHistory(computerMove); // update chessboard\n\n      setFen(chess.fen());\n    }\n  }, 300);\n};\n\n_c = MiniMax;\n\nconst getBoardEvaluation = board => {\n  let count = 0;\n\n  for (let i = 0; i < board.length; i++) {\n    for (let j = 0; j < board[i].length; j++) {\n      if (board[i][j] === null) continue;\n      let piece = board[i][j].type;\n      let color = board[i][j].color;\n\n      if (color === 'b') {\n        count += pieceValues[piece];\n      } else {\n        count -= pieceValues[piece];\n      }\n    }\n  }\n\n  return count;\n};\n\nexport default MiniMax;\n\nvar _c;\n\n$RefreshReg$(_c, \"MiniMax\");","map":{"version":3,"sources":["/Users/donavynhaley/Documents/GitHub/chess-ai/chess-ai/src/components/bots/MiniMax.js"],"names":["Chess","pieceValues","Map","buildTree","chessCopy","moves","depth","allEval","originalFen","d","i","length","move","push","score","getBoardEvaluation","board","load","MiniMax","chess","updateComputerHistory","setRandomBotAvaliableMoves","setFen","fen","setTimeout","console","log","computerMove","Math","floor","random","count","j","piece","type","color"],"mappings":"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","sourcesContent":["import Chess from \"chess.js\";\n\n/* \n    - Create copy of chess board\n    - get moves\n    - go through each move and get its evaluation\n    - run minmax evaulating each move to a height of 3\n*/\n\n/* based on stockfish midgame piece evaluations\nPawnValueMg = 128, \nKnightValueMg = 781,\nBishopValueMg = 825, \nRookValueMg = 1276, \nQueenValueMg = 2538,\n\n*/\nlet pieceValues = new Map()\npieceValues['p'] = 128;\npieceValues['n'] = 781;\npieceValues['b'] = 128;\npieceValues['r'] = 1276;\npieceValues['q'] = 2538;\npieceValues['k'] = 9999;\n\nconst buildTree = (chessCopy, moves, depth, allEval, originalFen) => {\n    for (let d = 0; d < depth; d++) {\n        for (let i = 0; i < moves.length; i++) {\n            chessCopy.move(moves[i]);\n            allEval.push({ score: getBoardEvaluation(chessCopy.board()), move: moves[i], depth: d });\n            chessCopy.load(originalFen)\n        }\n    }\n}\nconst MiniMax = (chess, updateComputerHistory, setRandomBotAvaliableMoves, setFen) => {\n    const originalFen = chess.fen();\n    const allEval = []\n    const chessCopy = new Chess(chess.fen());\n    allEval.push({ score: getBoardEvaluation(chess.board), move: 'origninal', depth: 2 })\n    // computer response random\n    setTimeout(() => {\n        // Get list of valid moves and adds evaluation for each possible move to list\n        const moves = chessCopy.moves();\n        buildTree(chessCopy, moves, 3, allEval, originalFen)\n        console.log(allEval)\n        // update state for data vizualization\n        // setRandomBotAvaliableMoves(moves);\n\n        // If valid move is avaliable selects random and updates chessboard\n        if (moves.length > 0) {\n            const computerMove = moves[Math.floor(Math.random() * moves.length)];\n            chess.move(computerMove);\n\n            // add move to history\n            updateComputerHistory(computerMove);\n\n            // update chessboard\n            setFen(chess.fen());\n        }\n    }, 300)\n}\nconst getBoardEvaluation = (board) => {\n    let count = 0;\n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[i].length; j++) {\n            if (board[i][j] === null)\n                continue\n            let piece = board[i][j].type\n            let color = board[i][j].color\n            if (color === 'b') {\n                count += pieceValues[piece]\n            }\n            else {\n                count -= pieceValues[piece]\n            }\n        }\n    }\n    return count\n}\n\nexport default MiniMax\n"]},"metadata":{},"sourceType":"module"}