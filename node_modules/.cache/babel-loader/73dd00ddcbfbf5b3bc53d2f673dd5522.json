{"ast":null,"code":"import _regeneratorRuntime from\"/Users/donavynhaley/Documents/GitHub/chess-ai/chess-ai/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/donavynhaley/Documents/GitHub/chess-ai/chess-ai/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import Chess from\"chess.js\";import getBoardEvaluation from'./getBoardEvaluation';var miniMaxRecursive=function miniMaxRecursive(chessCopy,depth,allEval,isMax){if(depth===0){return[null,getBoardEvaluation(chessCopy.fen())];}var moves=chessCopy.moves();var bestMove=moves[Math.floor(Math.random()*moves.length)];if(isMax){var maxEval=-Infinity;for(var i=0;i<moves.length;i++){// Update move\nchessCopy.move(moves[i]);// Push board eval to list\nallEval[depth-1].push({score:getBoardEvaluation(chessCopy.fen()),move:moves[i],currentMove:i,totalMoves:moves.length-1,isMax:true});// Recursive call minimax with lower depth\nvar currentEval=miniMaxRecursive(chessCopy,depth-1,allEval,false)[1];// Undo move\nchessCopy.undo();// Sets best move according to currentEval max\nif(currentEval>maxEval){maxEval=currentEval;bestMove=moves[i];}}return[bestMove,maxEval];}else{var minEval=Infinity;for(var _i=0;_i<moves.length;_i++){// Update move\nchessCopy.move(moves[_i]);// Push board eval to list\nallEval[depth-1].push({score:getBoardEvaluation(chessCopy.fen()),move:moves[_i],currentMove:_i,totalMoves:moves.length-1,isMax:true});// Recursive call minimax with lower depth\nvar _currentEval=miniMaxRecursive(chessCopy,depth-1,allEval,true)[1];// Undo move\nchessCopy.undo();// Sets best move according to currentEval min\nif(_currentEval<minEval){minEval=_currentEval;bestMove=moves[_i];}}return[bestMove,minEval];}};var fetchBestMove=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(chessCopy,depth,allEval,isMax){var bestMove;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return miniMaxRecursive(chessCopy,depth,allEval,isMax);case 2:bestMove=_context.sent;return _context.abrupt(\"return\",bestMove[0]);case 4:case\"end\":return _context.stop();}}},_callee);}));return function fetchBestMove(_x,_x2,_x3,_x4){return _ref.apply(this,arguments);};}();var toTreeData=function toTreeData(allEval,treeData,depth){var i=depth-1;if(i<0)return treeData;for(var j=0;j<allEval[i].length;j++){treeData.children.push({name:allEval[i][j].move,attributes:{score:allEval[i][j].score},children:[]});}i-=1;if(i<0)return treeData;var index=0;for(var _j=0;_j<allEval[i].length;_j++){treeData.children[index].children.push({name:allEval[i][_j].move,attributes:{score:allEval[i][_j].score},children:[]});if(allEval[i][_j].currentMove===allEval[i][_j].totalMoves){index+=1;}}index=0;var indexTwo=0;i-=1;if(i<0)return treeData;for(var _j2=0;_j2<allEval[i].length;_j2++){treeData.children[indexTwo].children[index].children.push({name:allEval[i][_j2].move,attributes:{score:allEval[i][_j2].score},children:[]});if(allEval[i][_j2].currentMove===allEval[i][_j2].totalMoves){index+=1;if(index>=treeData.children[indexTwo].children.length){indexTwo+=1;index=0;}}}return treeData;};var MiniMax=function MiniMax(chess,updateComputerHistory,setFen,setEvalCount,setTreeData,depth){var allEval=[[],[],[]];var treeData={name:\"Start\",attributes:{score:getBoardEvaluation(chess.fen())},children:[]};var chessCopy=new Chess(chess.fen());fetchBestMove(chessCopy,depth,allEval,true).then(function(bestMove){// update position\nchess.move(bestMove);console.log(allEval);// Update eval count\nvar totalEvaluations=allEval.map(function(evaluation){return evaluation.length;});setEvalCount(totalEvaluations.reduce(function(a,b){return a+b;},0));// convert to tree data\nsetTreeData(toTreeData(allEval,treeData,depth));// add move to history\nupdateComputerHistory(bestMove);// update chessboard\nsetFen(chess.fen());});};export default MiniMax;","map":{"version":3,"sources":["/Users/donavynhaley/Documents/GitHub/chess-ai/chess-ai/src/components/bots/MiniMax.js"],"names":["Chess","getBoardEvaluation","miniMaxRecursive","chessCopy","depth","allEval","isMax","fen","moves","bestMove","Math","floor","random","length","maxEval","Infinity","i","move","push","score","currentMove","totalMoves","currentEval","undo","minEval","fetchBestMove","toTreeData","treeData","j","children","name","attributes","index","indexTwo","MiniMax","chess","updateComputerHistory","setFen","setEvalCount","setTreeData","then","console","log","totalEvaluations","map","evaluation","reduce","a","b"],"mappings":"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","sourcesContent":["import Chess from \"chess.js\";\nimport getBoardEvaluation from './getBoardEvaluation'\n\n\nconst miniMaxRecursive = (chessCopy, depth, allEval, isMax) => {\n    if (depth === 0) {\n        return [null, getBoardEvaluation(chessCopy.fen())];\n    }\n\n    const moves = chessCopy.moves();\n    let bestMove = moves[Math.floor(Math.random() * moves.length)];\n\n    if (isMax) {\n        let maxEval = -Infinity;\n        for (let i = 0; i < moves.length; i++) {\n            // Update move\n            chessCopy.move(moves[i])\n            // Push board eval to list\n            allEval[depth - 1].push({ score: getBoardEvaluation(chessCopy.fen()), move: moves[i], currentMove: i, totalMoves: moves.length - 1, isMax: true })\n            // Recursive call minimax with lower depth\n            let currentEval = miniMaxRecursive(chessCopy, depth - 1, allEval, false)[1];\n            // Undo move\n            chessCopy.undo();\n            // Sets best move according to currentEval max\n            if (currentEval > maxEval) {\n                maxEval = currentEval;\n                bestMove = moves[i];\n            }\n        }\n        return [bestMove, maxEval];\n    }\n    else {\n        let minEval = Infinity;\n        for (let i = 0; i < moves.length; i++) {\n            // Update move\n            chessCopy.move(moves[i])\n            // Push board eval to list\n            allEval[depth - 1].push({ score: getBoardEvaluation(chessCopy.fen()), move: moves[i], currentMove: i, totalMoves: moves.length - 1, isMax: true })\n            // Recursive call minimax with lower depth\n            let currentEval = miniMaxRecursive(chessCopy, depth - 1, allEval, true)[1];\n            // Undo move\n            chessCopy.undo()\n            // Sets best move according to currentEval min\n            if (currentEval < minEval) {\n                minEval = currentEval;\n                bestMove = moves[i];\n            }\n        }\n        return [bestMove, minEval]\n    }\n}\n\nconst fetchBestMove = async (chessCopy, depth, allEval, isMax) => {\n    const bestMove = await miniMaxRecursive(chessCopy, depth, allEval, isMax)\n    return bestMove[0]\n}\n\nconst toTreeData = (allEval, treeData, depth) => {\n    let i = depth - 1\n    if (i < 0)\n        return treeData\n\n    for (let j = 0; j < allEval[i].length; j++) {\n        treeData.children.push({\n            name: allEval[i][j].move,\n            attributes: {\n                score: allEval[i][j].score,\n            },\n            children: []\n        })\n    }\n    i -= 1\n    if (i < 0)\n        return treeData\n\n    let index = 0\n    for (let j = 0; j < allEval[i].length; j++) {\n        treeData.children[index].children.push({\n            name: allEval[i][j].move,\n            attributes: {\n                score: allEval[i][j].score,\n            },\n            children: []\n        })\n        if (allEval[i][j].currentMove === allEval[i][j].totalMoves) {\n            index += 1\n        }\n    }\n    index = 0\n    let indexTwo = 0\n    i -= 1\n    if (i < 0)\n        return treeData\n\n    for (let j = 0; j < allEval[i].length; j++) {\n        treeData.children[indexTwo].children[index].children.push({\n            name: allEval[i][j].move,\n            attributes: {\n                score: allEval[i][j].score,\n            },\n            children: []\n        })\n        if (allEval[i][j].currentMove === allEval[i][j].totalMoves) {\n            index += 1\n            if (index >= treeData.children[indexTwo].children.length) {\n                indexTwo += 1\n                index = 0\n            }\n        }\n    }\n    return treeData\n}\nconst MiniMax = (chess, updateComputerHistory, setFen, setEvalCount, setTreeData, depth) => {\n    const allEval = [[], [], []]\n    const treeData = {\n        name: \"Start\",\n        attributes: {\n            score: getBoardEvaluation(chess.fen()),\n        },\n        children: []\n    }\n    const chessCopy = new Chess(chess.fen());\n    fetchBestMove(chessCopy, depth, allEval, true).then((bestMove) => {\n\n        // update position\n        chess.move(bestMove);\n        console.log(allEval);\n\n        // Update eval count\n        const totalEvaluations = allEval.map((evaluation) => {\n            return evaluation.length\n        })\n        setEvalCount(totalEvaluations.reduce((a, b) => a + b, 0))\n\n        // convert to tree data\n        setTreeData(toTreeData(allEval, treeData, depth))\n        // add move to history\n        updateComputerHistory(bestMove);\n\n        // update chessboard\n        setFen(chess.fen());\n    })\n}\n\n\nexport default MiniMax\n"]},"metadata":{},"sourceType":"module"}