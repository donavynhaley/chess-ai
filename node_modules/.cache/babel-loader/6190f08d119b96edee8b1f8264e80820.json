{"ast":null,"code":"import Chess from \"chess.js\";\nimport getBoardEvaluation from './getBoardEvaluation';\n/* \n    - Create copy of chess board\n    - get moves\n    - go through each move and get its evaluation\n    - run minmax evaulating each move to a height of 3\n*/\n\nconst miniMaxRecursive = (chessCopy, depth, allEval, isMax) => {\n  if (depth === 0) {\n    return [null, getBoardEvaluation(chessCopy.board())];\n  }\n\n  const moves = chessCopy.moves();\n  let bestMove = moves[moves.length - 1];\n\n  if (isMax) {\n    let maxEval = -Infinity;\n\n    for (let i = 0; i < moves.length; i++) {\n      chessCopy.move(moves[i]);\n      allEval[depth - 1].push({\n        score: getBoardEvaluation(chessCopy.board()),\n        move: moves[i],\n        moves: `${i}/${moves.length - 1}`,\n        isMax: true\n      });\n      let currentEval = miniMaxRecursive(chessCopy, depth - 1, allEval, false)[1];\n      chessCopy.undo(); //console.log(\"Current Eval: \" + currentEval + \"| Max Eval \" + maxEval)\n\n      if (currentEval > maxEval) {\n        maxEval = currentEval;\n        bestMove = moves[i];\n      }\n    }\n\n    return [bestMove, maxEval];\n  } else {\n    let minEval = Infinity;\n\n    for (let i = 0; i < moves.length; i++) {\n      chessCopy.move(moves[i]);\n      allEval[depth - 1].push({\n        score: getBoardEvaluation(chessCopy.board()),\n        move: moves[i],\n        moves: `${i}/${moves.length - 1}`,\n        isMax: false\n      });\n      let currentEval = miniMaxRecursive(chessCopy, depth - 1, allEval, true)[1];\n      chessCopy.undo();\n\n      if (currentEval < minEval) {\n        minEval = currentEval;\n        bestMove = moves[i];\n      }\n    }\n\n    return [bestMove, minEval];\n  }\n};\n\nconst fetchBestMove = async (chessCopy, depth, allEval, isMax) => {\n  const bestMove = await miniMaxRecursive(chessCopy, depth, allEval, isMax);\n  console.log(bestMove);\n  return bestMove[0];\n};\n\nconst MiniMax = (chess, updateComputerHistory, setFen) => {\n  const allEval = [[], [], [], []];\n  const chessCopy = new Chess(chess.fen());\n  getBoardEvaluation(chess.fen()); // computer response random\n  // fetchBestMove(chessCopy, 3, allEval, true).then((bestMove) => {\n  //     // update position\n  //     chess.move(bestMove);\n  //     console.log(allEval);\n  //     // add move to history\n  //     updateComputerHistory(bestMove);\n  //     // update chessboard\n  //     setFen(chess.fen());\n  // })\n};\n\n_c = MiniMax;\nexport default MiniMax;\n\nvar _c;\n\n$RefreshReg$(_c, \"MiniMax\");","map":{"version":3,"sources":["/Users/donavynhaley/Documents/GitHub/chess-ai/chess-ai/src/components/bots/MiniMax.js"],"names":["Chess","getBoardEvaluation","miniMaxRecursive","chessCopy","depth","allEval","isMax","board","moves","bestMove","length","maxEval","Infinity","i","move","push","score","currentEval","undo","minEval","fetchBestMove","console","log","MiniMax","chess","updateComputerHistory","setFen","fen"],"mappings":"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","sourcesContent":["import Chess from \"chess.js\";\nimport getBoardEvaluation from './getBoardEvaluation'\n/* \n    - Create copy of chess board\n    - get moves\n    - go through each move and get its evaluation\n    - run minmax evaulating each move to a height of 3\n*/\n\n\nconst miniMaxRecursive = (chessCopy, depth, allEval, isMax) => {\n    if (depth === 0) {\n        return [null, getBoardEvaluation(chessCopy.board())];\n    }\n    const moves = chessCopy.moves();\n    let bestMove = moves[moves.length - 1];\n\n    if (isMax) {\n        let maxEval = -Infinity;\n        for (let i = 0; i < moves.length; i++) {\n            chessCopy.move(moves[i])\n            allEval[depth - 1].push({ score: getBoardEvaluation(chessCopy.board()), move: moves[i], moves: `${i}/${moves.length - 1}`, isMax: true })\n            let currentEval = miniMaxRecursive(chessCopy, depth - 1, allEval, false)[1];\n            chessCopy.undo();\n            //console.log(\"Current Eval: \" + currentEval + \"| Max Eval \" + maxEval)\n            if (currentEval > maxEval) {\n                maxEval = currentEval;\n                bestMove = moves[i];\n            }\n        }\n        return [bestMove, maxEval];\n\n    }\n    else {\n        let minEval = Infinity;\n        for (let i = 0; i < moves.length; i++) {\n            chessCopy.move(moves[i])\n            allEval[depth - 1].push({ score: getBoardEvaluation(chessCopy.board()), move: moves[i], moves: `${i}/${moves.length - 1}`, isMax: false })\n            let currentEval = miniMaxRecursive(chessCopy, depth - 1, allEval, true)[1];\n            chessCopy.undo()\n            if (currentEval < minEval) {\n                minEval = currentEval;\n                bestMove = moves[i];\n            }\n        }\n        return [bestMove, minEval]\n    }\n\n}\n\nconst fetchBestMove = async (chessCopy, depth, allEval, isMax) => {\n    const bestMove = await miniMaxRecursive(chessCopy, depth, allEval, isMax)\n    console.log(bestMove)\n    return bestMove[0]\n}\n\nconst MiniMax = (chess, updateComputerHistory, setFen) => {\n    const allEval = [[], [], [], []]\n    const chessCopy = new Chess(chess.fen());\n    getBoardEvaluation(chess.fen())\n    // computer response random\n    // fetchBestMove(chessCopy, 3, allEval, true).then((bestMove) => {\n\n    //     // update position\n    //     chess.move(bestMove);\n    //     console.log(allEval);\n\n    //     // add move to history\n    //     updateComputerHistory(bestMove);\n\n    //     // update chessboard\n    //     setFen(chess.fen());\n    // })\n}\n\n\nexport default MiniMax\n"]},"metadata":{},"sourceType":"module"}